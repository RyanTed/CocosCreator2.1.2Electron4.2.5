"use strict";

var _require = require('child_process'),
    exec = _require.exec;

var adb = require('adbkit');

var chromeLauncher = require('chrome-simple-launcher');

var path = require('path');

var portfinder = require('portfinder');

var request = require('request'); // Constants of inspector/devtools.


var LOCAL_HOST = '127.0.0.1'; // TODO: Now all apps using mi-webview share the same domain socket prefix,
// the prefix should be move to 'hybrid_' once the socket names get decoupled.

var MIWEBVIEW_DEVTOOLS_PORT_REGEX = /(miui_)?webview_devtools_remote_(\d+)/;
var NETSTAT_STATUS_LISTENING = 'LISTENING';
var BROWSER_STRING = 'Browser';
var TITLE_STRING = 'title';
var WEBSOCKET_DEBUGGER_URL_STRING = 'webSocketDebuggerUrl';
var CHROME_INSPECTOR_URL = 'https://devtools.inf.miui.com/inspector/';
var CHROME_BUNDLED_INSPECTOR_URL = 'chrome-devtools://devtools/bundled/inspector.html';
var CHROME_INSPECTOR_QUERY = 'remoteFrontend=true&dockSide=undocked'; // 使用adb-driver中的文件(临时借用)

var MODULE_ROOT_DIR = path.join(__dirname, '../../node_modules/adb-driver');
var ADB_BINARY = {
  win32: path.resolve(MODULE_ROOT_DIR, 'bin', 'window', 'adb.exe'),
  darwin: path.resolve(MODULE_ROOT_DIR, 'bin', 'mac', 'adb'),
  linux: path.resolve(MODULE_ROOT_DIR, 'bin', 'linux', 'adb') // options

};
var useDesktopbundled = false;
var printOnly = false;

function getInspectablePageListURL(port) {
  return "http://".concat(LOCAL_HOST, ":").concat(port, "/json/list");
}

function getInspectableVersionURL(port) {
  return "http://".concat(LOCAL_HOST, ":").concat(port, "/json/version");
}

function getInspectorUrl(version) {
  if (!version) return;

  if (useDesktopbundled) {
    return CHROME_BUNDLED_INSPECTOR_URL;
  }

  var VERSTION_71 = '71.0.3578.132';
  var VERSTION_61 = '61.0.3163.128';

  if (version.split('.')[0] > 61) {
    version = VERSTION_71;
  } else {
    version = VERSTION_61;
  }

  return "".concat(CHROME_INSPECTOR_URL).concat(version, "/inspector.html");
}

function forwardPort(device, client, port, localabstract) {
  // Local tcp port is based on the pid of target game process.
  portfinder.basePort = port;
  portfinder.getPortPromise().then(function (port) {
    var portForward = "tcp:".concat(port, " localabstract:").concat(localabstract);
    console.log(device.id);
    console.log(portForward);
    return client.forward(device.id, "tcp:".concat(port), "localabstract:".concat(localabstract)).then(function () {
      console.log('Setup port forawrd.');
      getAvailablePages(port);
    })["catch"](function () {
      console.log('Port forward already setup.');
      getAvailablePages(port);
    });
  })["catch"](function () {
    console.error('Can not find valid port forward.');
  });
} // `getAvailablePages` : get available debuggable page and print out the
// full inspector url.


function getAvailablePages(port) {
  var pageListUrl = getInspectablePageListURL(port);
  var versionUrl = getInspectableVersionURL(port); // Request the inspectable version first.

  request(versionUrl, function (err, res) {
    if (err) {
      return console.log('Error request version information' + err);
    } // The version content should look like: "Chrome/61.0.3363.128"


    var content = JSON.parse(res.body);
    var chromeVersion = content[BROWSER_STRING];

    if (!chromeVersion) {
      return console.log('Error, can\'t get chrome version.');
    }

    chromeVersion = chromeVersion.split('/')[1];
    var inspectorUrl = getInspectorUrl(chromeVersion); // Then request the debuggable pages information.

    request(pageListUrl, function (err, res) {
      if (err) {
        return console.log('Error request inspectable pages: ' + err);
      } // Result content is JSON formatted dictionary of inspectable pages.


      var pages = JSON.parse(res.body);
      pages.map(function (page) {
        var title = page[TITLE_STRING]; // ignore others pages
        // if (title !== 'quickgame') return

        var webSocketDebuggerUrl = page[WEBSOCKET_DEBUGGER_URL_STRING];

        if (webSocketDebuggerUrl) {
          webSocketDebuggerUrl = webSocketDebuggerUrl.replace('ws://', 'ws='); // Print debug url.

          var debuggerUrl = "".concat(inspectorUrl, "?").concat(CHROME_INSPECTOR_QUERY, "&").concat(webSocketDebuggerUrl);
          console.log('Page: ' + title);
          console.log('    Debugger URL: ' + debuggerUrl);

          if (!printOnly) {
            chromeLauncher.launch(debuggerUrl).then(function () {
              console.log('Debugger URL opened in Chrome.');
            });
          }
        }
      });
    });
  });
}

function getDebuggerUrl() {
  var client = adb.createClient({
    bin: ADB_BINARY[process.platform]
  });
  client.listDevices().then(function (devices) {
    if (devices.length === 0) {
      throw new Error('No Device attached to PC.');
    }

    return Promise.all(devices.map(function (device) {
      return new Promise(function (resolve, reject) {
        client.shell(device.id, 'netstat -anl').then(adb.util.readAll).then(function (output) {
          if (!output) {
            throw new Error('No network connections.');
          }

          var outputStats = output.toString().trim().split('\n');
          outputStats.map(function (line) {
            if (line.search(NETSTAT_STATUS_LISTENING) !== -1) {
              var result = line.match(MIWEBVIEW_DEVTOOLS_PORT_REGEX);

              if (result) {
                var pid = result[2];
                console.log('pid', pid);
                client.shell(device.id, "ps ".concat(pid)).then(adb.util.readAll).then(function (output) {
                  var psLine = output.toString().trim().split('\n')[1];

                  if (psLine && psLine.match(/com.miui.hybrid:Launcher(\d+)/)) {
                    forwardPort(device, client, pid, result[0]);
                  }

                  console.log('output', psLine);
                });
              }
            }
          });
        }).then(function (data) {
          return resolve(data);
        })["catch"](function (err) {
          return reject(err);
        });
      });
    }));
  }).then(function () {
    console.log('Debugger setup.');
  })["catch"](function (err) {
    console.error('Error in generating debugger URL:', err.stack);
  });
}

module.exports = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (options.useDesktopbundled) {
    useDesktopbundled = true;
  }

  if (options.printOnly) {
    printOnly = true;
  }

  exec('adb forward --remove-all', function (err) {
    if (err) {
      console.error('Error clear port forward');
    }

    getDebuggerUrl();
  });
};