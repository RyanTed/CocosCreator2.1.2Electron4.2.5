"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _dayjs = _interopRequireDefault(require("dayjs"));

var _utils = require("../utils");

var _rpks = require("../subpackages/rpks");

/**
 * 递归遍历 base 目录下的所有文件
 * 并按照优先级进行排序
 *
 * @param {String} base - 目标目录
 * @returns {Array<String>|Boolean} - 文件列表
 */
function resolveFiles(base, priorities) {
  var files = (0, _utils.lsdirdeep)(base);

  if (files.includes(_rpks.DIGEST_ZIP_PATH)) {
    console.warning("\u68C0\u6D4B\u5230\u5B58\u5728\u5FEB\u6E38\u620F\u4FDD\u7559\u6587\u4EF6: ".concat(_rpks.DIGEST_ZIP_PATH));
    return false;
  } // 按照流式包的策略对文件进行排序


  files = (0, _utils.sortFilesBy)(files, priorities);
  return files;
}
/**
 * 将 dist 中的文件压缩成 rpk 包，并为其签名
 *
 * @param {Object} options - 插件参数对象
 * @param {String} options.name - 包名
 * @param {String} options.output - dist 文件夹路径
 * @param {String} options.pathBuild - rpk 包输出路径
 * @param {String} options.sign - 使用 debug 或 release 签名
 * @param {String} options.versionCode
 * @param {Boolean} options.disableStreamPack - 停止流式打包
 * @param {Array<String>} options.priorities - 压缩文件顺序优先级参考数组，将按此数组先后压缩文件
 */


function ZipPlugin() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  this.options = Object.assign({
    // 默认排序
    priorities: ['manifest.json', 'main.js']
  }, options);
}
/**
 * 把rpks/rpk文件写到磁盘
 * @param contentBuffer
 * @param options
 * @param watch
 * @param distExt [rpks|rpk]
 */


function generateDistFile(contentBuffer, options, watch, distExt) {
  var distFileName = "".concat(options.name, ".").concat(options.sign, ".").concat(distExt);

  var distFilePath = _path["default"].join(options.output, distFileName);

  _fs["default"].writeFileSync(distFilePath, contentBuffer);

  _utils.colorconsole.log("### App Loader ### dist\u76EE\u5F55\u7B7E\u540D\u5E76\u751F\u6210".concat(distExt, "\u6587\u4EF6\uFF1A").concat(distFileName)); // 非监听模式下，复制一份：包名，版本，时间戳，满足部分 CP 的需求


  if (!watch && options.copyRpk) {
    var dupBuildFileTime = (0, _dayjs["default"])().format('YYYYMMDDhhmmss');
    var dupBuildFileName = "".concat(options.name, "_").concat(options.sign, "_").concat(options.versionCode, "_").concat(dupBuildFileTime, ".").concat(distExt);

    var dupBuildFilePath = _path["default"].join(options.output, dupBuildFileName);

    _fs["default"].writeFileSync(dupBuildFilePath, contentBuffer);

    _utils.colorconsole.log("### App Loader ### \u590D\u5236".concat(distExt, "\u6587\u4EF6(").concat(distFileName, ")\u4E3A\u6587\u4EF6(").concat(dupBuildFileName, ")"));
  }
}

ZipPlugin.prototype.apply = function (compiler) {
  var options = this.options;
  var projectPath = options.projectPath; // 签名文件

  var SignFileConfig = {
    debug: {
      privatekey: _path["default"].join(projectPath, 'sign/debug', 'private.pem'),
      certificate: _path["default"].join(projectPath, 'sign/debug', 'certificate.pem')
    },
    release: {
      privatekey: _path["default"].join(projectPath, 'sign/release', 'private.pem'),
      certificate: _path["default"].join(projectPath, 'sign/release', 'certificate.pem')
    } // 签名：<无|debug|release>

  };
  var signFile = SignFileConfig[options.sign];
  var subpackageOptions;

  if (!options.disableSubpackages && options.subpackages && options.subpackages.length > 0) {
    subpackageOptions = options.subpackages;
  }

  compiler.hooks.afterEmit.tapAsync('ZipPlugin', function (compilation, callback) {
    if (!signFile) {
      _utils.colorconsole.log('### App Loader ### 无签名配置项, 放弃打包: ' + options.sign);

      callback();
      return;
    }

    var privatekey = signFile.privatekey,
        certificate = signFile.certificate;

    if (!_fs["default"].existsSync(privatekey)) {
      _utils.colorconsole.log('### App Loader ### 缺少私钥文件, 打包失败: ' + privatekey);

      callback();
      return;
    }

    if (!_fs["default"].existsSync(certificate)) {
      _utils.colorconsole.log('### App Loader ### 缺少证书文件, 打包失败: ' + certificate);

      callback();
      return;
    }

    privatekey = _fs["default"].readFileSync(privatekey);
    certificate = _fs["default"].readFileSync(certificate);
    var files = resolveFiles(options.pathBuild, options.priorities);

    if (files === false) {
      callback();
      return;
    }

    var _createPackagesDefini = (0, _rpks.createPackagesDefinition)(subpackageOptions),
        fullPackage = _createPackagesDefini.fullPackage,
        subPackages = _createPackagesDefini.subPackages; // 遍历文件分配文件资源到每个package里面, 包括digest, file hash


    (0, _rpks.allocateResourceToPackages)(files, options.pathBuild, fullPackage, subPackages); // 生成最终产出带签名的rpks和rpk文件buffer

    (0, _rpks.signZipPkgs)(options.name, privatekey, certificate, fullPackage, subPackages, options.disableStreamPack).then(function (_ref) {
      var rpksBuffer = _ref.rpksBuffer,
          rpkBuffer = _ref.rpkBuffer;

      _fs["default"].mkdir(options.output, function () {
        if (rpksBuffer) {
          generateDistFile(rpksBuffer, options, compiler.watchMode, 'rpks');
        }

        generateDistFile(rpkBuffer, options, compiler.watchMode, 'rpk');
        callback();
      });
    });
  });
};

module.exports = ZipPlugin;