"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _utils = require("../utils");

/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */
// 打包资源文件白名单, cocos需要.js文件（单独处理）
var FILE_INCLUDE_EXT = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.json', '.cer', '.obj', '.dae', '.fbx', '.mtl', '.stl', '.3ds', '.mp3', '.pvr', '.wav', '.plist', '.ttf', '.fnt', '.gz', '.ccz', '.m4a', '.mp4', '.bmp', '.atlas', '.swf', '.ani', '.part', '.proto', '.bin', '.sk', '.mipmaps', '.txt', '.zip', '.ogg', '.silk', '.dbbin', '.dbmv', '.etc', '.lmat', '.lm', '.ls', '.lh', '.lani', '.lav', '.lsani', '.ltc', '.csv', '.scene', '.prefab', '.lml', '.lmani', '.ktx', '.dds', '.xml']; // 排除指定文件

var EXCLUDE_FILES = ['package.json', 'package-lock.json', 'babel.config.js', '.eslintrc.js', '.eslintignore']; // 排除资源文件的文件名
// 兼容wxGame平级目录 排除 dist sign node

var EXCLUDE_DIRS = ['.DS_Store', 'Thumbs.db', '.idea', 'dist', 'sign', 'node_modules'];

function ResourcePlugin(options) {
  this.options = options;
}

function updateManifest(manifest, debug) {
  // 更新 config.debug
  manifest.config = manifest.config || {};
  manifest.config.debug = debug; // 更新type

  if (!manifest.type) {
    manifest.type = 'game';
  }

  return manifest;
}

ResourcePlugin.prototype.apply = function (compiler) {
  var options = this.options;
  var webpackOptions = compiler.options;
  var isCocosWxGame = options.cocosWxGame; // 需要排除的文件夹

  var ignoreDirs = options.ignoreDir && options.ignoreDir.split(',') || [];
  EXCLUDE_DIRS = EXCLUDE_DIRS.concat(ignoreDirs); // 监听时处理

  compiler.hooks.watchRun.tapAsync('ResourcePlugin', function (watching, callback) {
    Object.keys(webpackOptions.entry).forEach(function (key) {
      var val = webpackOptions.entry[key];

      if (val instanceof Array && !/app\.js/.test(key)) {
        // 删除webpack-dev-server注入的watch依赖
        val[0].indexOf('webpack-dev-server') !== -1 && val.shift();
      }
    });
    callback();
  });
  compiler.hooks.emit.tapAsync('ResourcePlugin', function (compilation, callback) {
    var projectPath = options.projectPath;
    var pathBuild = options.pathBuild;
    var innerInputFS = compilation.compiler.inputFileSystem;
    var innerOutputFS = compilation.compiler.outputFileSystem; // cocos小游戏,动态require需要拷贝js文件到build目录

    if (isCocosWxGame) {
      FILE_INCLUDE_EXT.unshift('.js');
    }

    var RegExcludeDir = new RegExp("(".concat(EXCLUDE_DIRS.join('|'), ")")); // 搜集资源文件

    var res = (0, _utils.collectResFile)(projectPath, pathBuild, FILE_INCLUDE_EXT, RegExcludeDir, EXCLUDE_FILES);
    var resnum = Object.keys(res).length; // 拷贝资源文件

    Object.keys(res).forEach(function (resDestFile) {
      var resSrcFile = res[resDestFile]; // 确保目标目录存在

      innerOutputFS.mkdirp(_path["default"].dirname(resDestFile), function () {
        var resSrcFileStat = innerInputFS.statSync(resSrcFile); // 处理每个文件

        if (resSrcFileStat && resSrcFileStat.isFile()) {
          // 复制文件
          innerInputFS.readFile(resSrcFile, function (err, data) {
            if (err) {
              _utils.colorconsole.log("### App Loader ### \u590D\u5236\u8D44\u6E90\u6587\u4EF6(".concat(resSrcFile, ")\u5931\u8D25\uFF1A").concat(err.message));
            }

            innerOutputFS.writeFile(resDestFile, data, function (err) {
              if (err) {
                _utils.colorconsole.log("### App Loader ### \u590D\u5236\u8D44\u6E90\u6587\u4EF6(".concat(resDestFile, ")\u5931\u8D25\uFF1A").concat(err.message));
              }

              nextCallback(resSrcFile, resDestFile);
            });
          });
        }
      });
    });

    function nextCallback() {
      if (--resnum > 0) {
        return;
      }

      _utils.colorconsole.log('### App Loader ### build目录构建完成');

      callback();
    }
  }); // 更新 build/manifest.json

  compiler.hooks.emit.tapAsync('ResourcePlugin', function (compilation, callback) {
    var sourceDir = options.projectPath;
    var targetDir = options.pathBuild;

    var pathManifestFrom = _path["default"].join(sourceDir, 'manifest.json');

    var pathManifestDest = _path["default"].join(targetDir, 'manifest.json');

    var fileExists = _fs["default"].existsSync(pathManifestFrom);

    if (fileExists) {
      var manifest;

      try {
        var manifestCont = _fs["default"].readFileSync(pathManifestFrom, 'utf8');

        manifest = JSON.parse(manifestCont);
      } catch (err) {
        _utils.colorconsole.error('ERROR: 解析 manifest.json 文件出错 %s', err.message);

        throw err;
      }

      var debug = !options.sign;
      manifest = updateManifest(manifest, debug); // minify in production mode

      var updatedContent = JSON.stringify(manifest, null, debug ? 2 : 0);

      _fs["default"].writeFile(pathManifestDest, updatedContent, 'utf8', function (err) {
        if (err) {
          _utils.colorconsole.error('### App Loader ### 更新 %s 失败：%s', err.message);
        }

        callback();
      });
    } else {
      _utils.colorconsole.error('### App Loader ### %s 下无 manifest.json 文件');

      callback();
    }
  });
};

module.exports = ResourcePlugin;