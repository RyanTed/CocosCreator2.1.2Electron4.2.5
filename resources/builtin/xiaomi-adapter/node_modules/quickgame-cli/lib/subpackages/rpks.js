"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPackagesDefinition = createPackagesDefinition;
exports.allocateResourceToPackages = allocateResourceToPackages;
exports.signZipPkgs = signZipPkgs;
exports.DIGEST_ZIP_PATH = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _jszip = _interopRequireDefault(require("jszip"));

var _sign = require("../sign");

var _utils = require("../utils");

/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */
// 主包保留名
var MAIN_PKG_NAME = 'base'; // 文件摘要包（zip 文件）

var DIGEST_ZIP_PATH = 'META-INF/CERT'; // 文件列表摘要的名称

exports.DIGEST_ZIP_PATH = DIGEST_ZIP_PATH;
var DEIGEST_HASH_JSON = 'hash.json'; // 分包的大小上限 5MB

var SINGLE_PKG_SIZE = 1024 * 1024 * 5; // 整包的大小上限 10MB

var FULL_PKG_SIZE = SINGLE_PKG_SIZE * 2; // 压缩参数，设置输出 buffer，以便对 buffer 进行操作

var COMPRESS_OPTS = {
  type: 'nodebuffer',
  compression: 'DEFLATE',
  compressionOptions: {
    level: 9
  }
};

function ClassPkgDef(options) {
  var pkgDef = {
    // 此包的包名
    fileName: null,
    // 此包是否为独立包
    standalone: false,
    // 此包的资源路径匹配
    subMatch: null,
    // 此包的打包文件列表
    resourceList: []
  };
  Object.assign(this, pkgDef, options);
}

ClassPkgDef.prototype.addResource = function (fileBuildPath, fileContentBuffer, fileContentDigest) {
  if (this.resourceList[fileBuildPath]) {
    throw new Error("### App Loader ### ".concat(fileBuildPath, " \u6587\u4EF6\u91CD\u590D\u6DFB\u52A0"));
  }

  this.resourceList[fileBuildPath] = true; // 先把文件buff存起来，后续无需再读取

  this.resourceList.push({
    fileBuildPath: fileBuildPath,
    fileContentBuffer: fileContentBuffer,
    fileContentDigest: fileContentDigest
  });
};
/**
 * 创建完整包定义
 * @returns {ClassPkgDef}
 */


function createFullPackage() {
  return new ClassPkgDef({
    fileName: 'rpk',
    standalone: true
  });
}
/**
 * 创建分包列表
 * @param {Array} subpackages - manifest的subpackages字段的内容
 * @returns {Object[]}  - 返回创建的分包列表
 */


function createSubPackages(subpackages) {
  // 分包列表
  var subPackages;
  subPackages = []; // 第一位为主包, 除了分包所属资源，剩余资源都是主包的

  var basePkg = new ClassPkgDef({
    fileName: MAIN_PKG_NAME + '.srpk',
    standalone: true
  });
  subPackages.push(basePkg);
  subpackages.forEach(function (subpkg) {
    var resouce = subpkg.root || subpkg.resource;
    var regStr = resouce; // 单文件

    if (/\.js$/.test(resouce)) {
      regStr = resouce;
    } else {
      regStr = resouce + '.*';
    }

    var partPkg = new ClassPkgDef({
      subMatch: new RegExp(regStr, 'i'),
      fileName: subpkg.name + '.srpk',
      standalone: subpkg.standalone || false
    });
    subPackages.push(partPkg);
  });
  return subPackages;
}
/**
 * 创建完整包和分包列表
 * @param {[]} subpackageOptions 如果有subpackages创建分包列表，如果没有不会创建分包列表
 * @returns {{fullPackage: *, subPackages: *}}
 */


function createPackagesDefinition(subpackageOptions) {
  var fullPackage = createFullPackage();
  var subPackages;

  if (subpackageOptions && subpackageOptions.length > 0) {
    subPackages = createSubPackages(subpackageOptions);
  }

  return {
    fullPackage: fullPackage,
    subPackages: subPackages
  };
}
/**
 * 将各资源分派给各个要打出来的包，包括digest, hashList, 以及实际的文件内容fileContentBuffer
 * @param {String[]} files 文件列表
 * @param {String} base 文件相对的目录
 * @param {ClassPkgDef} fullPackage 整包
 * @param {ClassPkgDef[]} subPackages 分包列表
 */


function allocateResourceToPackages(files, base, fullPackage, subPackages) {
  files.forEach(function (fileBuildPath) {
    var fileAbsPath = _path["default"].join(base, fileBuildPath);

    var fileContentBuffer = _fs["default"].readFileSync(fileAbsPath);

    var fileContentDigest = (0, _sign.getBufferDigest)(fileContentBuffer); // 资源基本信息

    var resourceInfo = [fileBuildPath, fileContentBuffer, fileContentDigest]; // 整包需要所有文件

    fullPackage.addResource.apply(fullPackage, resourceInfo);

    if (!subPackages) {
      return {
        fullPackage: fullPackage
      };
    } // 标志此资源是否属于主包，需要放入主包


    var belongToBasePkg = true; // 遍历除主包整包外的分包，判断此文件是否属于某个分包的

    for (var i = 1; i < subPackages.length; i++) {
      var pkg = subPackages[i]; // 如果此分包是个独立包，则需要加入manifest

      if (pkg.standalone && fileBuildPath === 'manifest.json') {
        pkg.addResource.apply(pkg, resourceInfo);
      }

      if (pkg.subMatch.test(fileBuildPath)) {
        belongToBasePkg = false;
        pkg.addResource.apply(pkg, resourceInfo); // 此资源已属于这个分包，无需循环下一轮

        break;
      }
    }

    if (belongToBasePkg) {
      var basePkg = subPackages[0];
      basePkg.addResource.apply(basePkg, resourceInfo);
    }
  });
}
/**
 * 返回摘要文件签名buff d
 * @param {[]} resourceList - 文件资源列表
 * @param {Buffer} privatekey - 私钥文件 buffer
 * @param {Buffer} certificate - 证书文件 buffer
 * @returns {Object} signedDigestBuf - 摘要文件签名buff
 */


function signZipResourcesMeta(resourceList, privatekey, certificate) {
  // 资源文件的摘要映射
  var fileDigestHash = {};
  resourceList.forEach(function (resourceFile) {
    fileDigestHash[resourceFile.fileBuildPath] = resourceFile.fileContentDigest.toString('hex');
  }); // ZIP元文件

  var metaZipFile = new _jszip["default"]();
  metaZipFile.file(DEIGEST_HASH_JSON, JSON.stringify({
    algorithm: 'SHA-256',
    digests: fileDigestHash
  }));
  return metaZipFile.generateAsync(COMPRESS_OPTS).then(function (digestBuf) {
    // 先将 DEIGEST_HASH_JSON 压缩到 DIGEST_ZIP_FATH 中
    var digestHash = {
      name: DEIGEST_HASH_JSON,
      hash: (0, _sign.getBufferDigest)(digestBuf)
    };
    return (0, _sign.signZip)(digestBuf, [digestHash], privatekey, certificate);
  });
}
/**
 * 为每个包生成签名内容
 * @param {ClassPkgDef} pkg 文件资源列表
 * @param {Buffer} privatekey - 私钥文件 buffer
 * @param {Buffer} certificate - 证书文件 buffer
 * @param {Boolean} disableStreamPack - 停止流式打包
 * @return {*}
 */


function signPackageZip(pkg, privatekey, certificate, disableStreamPack) {
  var resourceList = pkg.resourceList;
  var zipper = new _jszip["default"]();
  var hashList = resourceList.map(function (resourceFile) {
    return {
      name: resourceFile.fileBuildPath,
      hash: resourceFile.fileContentDigest
    };
  });
  return new Promise(function (resolve) {
    if (disableStreamPack) {
      resolve();
    } else {
      signZipResourcesMeta(resourceList, privatekey, certificate).then(function (metaSignedBuffer) {
        // 将 DIGEST_ZIP_FATH 最先加入应用包, 每个包都需要
        zipper.file(DIGEST_ZIP_PATH, metaSignedBuffer);
        hashList.unshift({
          name: DIGEST_ZIP_PATH,
          hash: (0, _sign.getBufferDigest)(metaSignedBuffer)
        });
        resolve();
      });
    }
  }).then(function () {
    var compressOpts = (0, _objectSpread2["default"])({}, COMPRESS_OPTS);
    resourceList.forEach(function (resourceFile) {
      zipper.file(resourceFile.fileBuildPath, resourceFile.fileContentBuffer);
    });
    return zipper.generateAsync(compressOpts);
  }).then(function (zipBuf) {
    return (// 生成签名文件
      (0, _sign.signZip)(zipBuf, hashList, privatekey, certificate)
    );
  });
}
/**
 * 将各个包的文件内容放入合包的zipper
 * @param {Object} pkgName - 此项目package名字
 * @param {Buffer} privatekey - 私钥文件 buffer
 * @param {Buffer} certificate - 证书文件 buffer
 * @param {ClassPkgDef} fullPackage 整包
 * @param {ClassPkgDef[]} subPackages 分包列表
 * @param {Boolean} disableStreamPack 关闭流式打包
 * @returns {Object}  最终要打包的内容
 */


function signZipPkgs(pkgName, privatekey, certificate, fullPackage, subPackages, disableStreamPack) {
  // 先生成整包rpk
  return signPackageZip(fullPackage, privatekey, certificate, disableStreamPack).then(function (rpkBuffer) {
    if (!subPackages) {
      return {
        rpkBuffer: rpkBuffer
      };
    }

    var rpksZipper = new _jszip["default"]();
    var rpksHashList = [];
    var subPkgSizeSum = 0;
    var subZipPromiseList = subPackages.map(function (pkg) {
      return signPackageZip(pkg, privatekey, certificate);
    }); // 遍历分包信息，生成zip buff

    return Promise.all(subZipPromiseList).then(function (signContents) {
      signContents.forEach(function (signContent, i) {
        var pkg = subPackages[i];
        var rpkBuildFileName = "".concat(pkgName, ".").concat(pkg.fileName); // 检查分包大小

        var size = signContent.length;
        subPkgSizeSum += size;

        _utils.colorconsole.log("### App Loader ### '".concat(rpkBuildFileName, "' \u5927\u5C0F\u4E3A ").concat(Math.ceil(size / 1024), " KB"));

        if (size > SINGLE_PKG_SIZE) {
          _utils.colorconsole.warn("### App Loader ### \u6BCF\u4E2A\u5206\u5305\u5927\u5C0F\u4E0D\u80FD\u5927\u4E8E ".concat(SINGLE_PKG_SIZE / 1024, " KB, '").concat(rpkBuildFileName, "' \u5DF2\u8D85\u51FA"));
        } // 把每个包的内容打入合包


        rpksZipper.file(rpkBuildFileName, signContent);
        rpksHashList.push({
          name: rpkBuildFileName,
          hash: (0, _sign.getBufferDigest)(signContent)
        });
      }); // 检查分包总和大小

      if (subPkgSizeSum > FULL_PKG_SIZE) {
        _utils.colorconsole.warn("### App Loader ### \u6240\u6709\u5206\u5305\u603B\u548C\u5927\u5C0F\u4E0D\u80FD\u5927\u4E8E ".concat(FULL_PKG_SIZE / 1024, " KB, \u5DF2\u8D85\u51FA"));
      } // 将整包信息加入


      var rpkBuildFileName = "".concat(pkgName, ".").concat(fullPackage.fileName);
      rpksZipper.file(rpkBuildFileName, rpkBuffer);
      rpksHashList.push({
        name: rpkBuildFileName,
        hash: (0, _sign.getBufferDigest)(rpkBuffer)
      });
      return rpksZipper.generateAsync(COMPRESS_OPTS);
    }).then(function (rpksZipBuf) {
      // 生成rpks文件buffer
      var rpksBuffer = (0, _sign.signZip)(rpksZipBuf, rpksHashList, privatekey, certificate);
      return {
        rpksBuffer: rpksBuffer,
        rpkBuffer: rpkBuffer
      };
    });
  });
}